#pragma once
#include <cstdio>
#include <cinttypes>

// Этот класс будет работать только с int'ом,
// но что, если понадобится, чтобы был не int, а float? Надо было бы во всех местах менять int на float. Неудобно.
// но все же закинем удочку на будущее.
typedef int Type;
// В дальнейшем компилятор вместо "Type" будет поставлять int.
// В случае, если захотим изменить тип, то его нужно будет изменить только в этой тайпдефе
// А что, если один список должен состоять из int'ов, а другой из float?
// Тут входят в чат шаблоны(templates, generics - это всё одно и то же). Их тут нет, дабы не усложнять, но это важный топик.

class List
{
public:

	struct Node
	{
		Type val;
		Node* p_next;
		// Определим тут конструктор, чтобы потом было удобно создавать узлы
		Node(Type val, Node* p_next = nullptr)
			: val(val), p_next(p_next)
		{}
	};

	// Вне этого класса(например в функции main после создания объекта) ты можешь пользоваться всеми этими публичными методами

	List();
	List(Type val);

	~List();

	// Возвращает размер списка
	size_t get_size();

	// true, если список пустой
	// false, если список не пустой
	bool is_empty();

	// Возвращает указатель на первых элемент
	Node* begin();
	// Возвращает указатель на элемент со значением val
	Node* find(Type val);

	// Добавляет в конец списка элемент со значением val
	void push_back(Type val);
	// Добавляет в начало списка элемент со значением val
	void push_front(Type val);
	// Добавляет элемент со значением val после элемента, на который указывает p_node
	void push_after(Node* p_node, Type val);

	// Удаляет первый элемент
	Type pop_front();
	// Удаляет последний элемент
	Type pop_back();
	// Удаляет элемент после элемента, на который указывает p_node
	Type pop_after(Node* p_node);
	// Удаляет элемент, на который указывает p_node
	Type pop(Node* p_node);

	// Удаляет все элементы, освобождая память
	void clear();

	// Печатает это дерьмо
	// этот класс ваще-то отвечает за логику, это как бы отдельный компонент, который отвечает только за списки
	// и, представим, что он настолько крутой, что используется в приложении инсты на андроиде
	// а там, ну, никаких консолей нет
	// поэтому так лучше не делать
	void print_this_shit();

private:

	// Указатель на первый элемент
	Node* p_head;
	// Указатель на последний элемент
	// Внимание, это небольшая оптимизация, преподу это должно понравиться.
	// Когда ты вставляешь элемент в конец, тебе нужно перебрать все элементы, пока не дойдешь до последнего
	// Но ты можешь хранить указатель на последний элемент и при такой вставке сразу переместиться на него, ничего не перебирая
	Node* p_last;
	// Размер списка
	size_t _size;

};

